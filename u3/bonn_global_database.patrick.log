> --
> -- Systemdatum Start
> --
> SELECT user,
         TO_CHAR(SYSDATE, 'dd-mm-yy hh24:mi:ss') 
  FROM   dual
  
USER                           TO_CHAR(SYSDATE,'DD-MM-YYHH24:MI:SS')
------------------------------ -------------------------------------
PROBIN2S                       06-05-15 14:48:41                    

> --
> -- ***************************************************************
> -- * Das globale Schema fuer den Standort Bonn  
> --
> --
> -- ***************************************************************
> -- * Initialisierung  
> --
> DROP VIEW rent
view RENT gelöscht.
> DROP VIEW article
view ARTICLE gelöscht.
> DROP VIEW customer
view CUSTOMER gelöscht.
> DROP DATABASE LINK london

Fehler beim Start in Zeile : 44 in Befehl -
DROP DATABASE LINK london
Fehlerbericht -
SQL-Fehler: ORA-02018: Datenbank-Link desselben Namens hat eine offene Verbindung
02018. 00000 -  "database link of same name has an open connection"
*Cause:    
*Action:
> DROP DATABASE LINK newyork

Fehler beim Start in Zeile : 45 in Befehl -
DROP DATABASE LINK newyork
Fehlerbericht -
SQL-Fehler: ORA-02018: Datenbank-Link desselben Namens hat eine offene Verbindung
02018. 00000 -  "database link of same name has an open connection"
*Cause:    
*Action:
> --
> -- ***************************************************************
> -- * Erstellung  
> --
> CREATE DATABASE LINK london using 'ORACLEDB_LONDON'

Fehler beim Start in Zeile : 52 in Befehl -
CREATE DATABASE LINK london using 'ORACLEDB_LONDON'
Fehler bei Befehlszeile : 52 Spalte : 22
Fehlerbericht -
SQL-Fehler: ORA-02011: Doppelter Datenbank-Link-Name
02011. 00000 -  "duplicate database link name"
*Cause:    
*Action:
> CREATE DATABASE LINK newyork using 'ORACLEDB_NEWYORK'

Fehler beim Start in Zeile : 53 in Befehl -
CREATE DATABASE LINK newyork using 'ORACLEDB_NEWYORK'
Fehler bei Befehlszeile : 53 Spalte : 22
Fehlerbericht -
SQL-Fehler: ORA-02011: Doppelter Datenbank-Link-Name
02011. 00000 -  "duplicate database link name"
*Cause:    
*Action:
> CREATE VIEW customer as
select * from ldn_customer@london
union all
select * from bnn_customer
union all
select * from nyk_customer@newyork
view CUSTOMER erstellt.
> CREATE VIEW article as
select * from ldn_article@london
union all
select * from bnn_article
union all
select * from nyk_article@newyork
view ARTICLE erstellt.
> CREATE VIEW rent as
select * from ldn_rent@london
union all
select * from bnn_rent
union all
select * from nyk_rent@newyork
view RENT erstellt.
> --
> -- ***************************************************************
> -- * Test der zehn Anwendungsfaelle  
> --
> -- 1.  new customer
> -- cannot work
> -- insert into customer(id_customer, company, address, zip, city, state) values((select max(id_customer) from customer)+1, 'Hollow Sword Blade Company', 'Square 1', 'EC1A1AH', 'City of London', 'United Kingdom');
> -- 2.  new article / bestellung vom supplier entgegennehmen
> -- cannot work
> -- insert into article(id_article, item, type, id_supplier,
> --	pur_baseprice, pur_currency, pur_purchasedate,
> --	sal_rentalpricemonth, sal_rentalpriceweek, sal_rentalpriceday, sal_currency,
> --	id_depot, dep_location, dep_weightkg, dep_heightcm, dep_lengthcm, dep_breadthcm)
> --values((select max(id_article) from article)+1,'Nova','Wrecking Ball',1,1,'Euro',sysdate,30,7,1,'Pound',2,10,1,1,1,1);
> -- 3.  customer rents article
> -- cannot work
> --insert into rent(id_customer, id_article, contract, rentfrom, rentto, returnflag) values(1,7,(select max(contract) from rent) + 1,sysdate,sysdate + interval '1' day,0);
> -- 4.  gibt es eine ausleihe, die bald (in unter einer woche) abl�uft
> SELECT ID_article, item, rentTo
FROM rent NATURAL JOIN article
WHERE ID_customer = 11
AND returnflag = 0
AND rentTo > sysdate
AND RENTTO < sysdate + 7
Keine Zeilen gewählt


> -- 5.  customer zieht um
> -- cannot work
> -- UPDATE customer
> -- SET address='Platz 1', city='Koblenz', zip=12345
> -- WHERE ID_customer = 11;
> -- 6.  customer gibt article zur�ck
> -- cannot work
> -- UPDATE rent
> -- SET returnflag=1
> -- WHERE ID_customer = 11
> -- AND ID_article = 17
> -- AND contract = 1;
> -- 7.  aktueller zustand depot (wie viele noch nicht verliehen)
> SELECT TYPE, count(ID_ARTICLE) - (
  SELECT count(ID_ARTICLE)
  FROM article NATURAL JOIN rent
  WHERE RENTFROM < sysdate
  AND RETURNFLAG = 0
  and id_depot = 1
) REMAINING
FROM article
where id_depot = 1
GROUP BY TYPE
TYPE                                                              REMAINING
---------------------------------------------------------------- ----------
Excavator                                                                 2

> -- 8.  ab wann erstes vom article wieder vorhanden
> SELECT TYPE, min(RENTTO) AVAILABLE_AT
FROM article NATURAL JOIN rent
WHERE returnFlag = 0
AND RENTFROM < sysdate 
AND RENTTO > sysdate
and id_depot = 1 -- optimize: use bnn_article ?
GROUP BY TYPE
Keine Zeilen gewählt


> -- 9.  Monatsabrechnung für Customer 1
> SELECT 
  a.ID_article, a.TYPE,
  nvl(d.DAYS, 0), nvl(d.DAYS, 0) * a.SAL_RENTALPRICEDAY PRICE_FOR_DAYS,
  nvl(w.WEEKS, 0), nvl(w.WEEKS, 0) * a.SAL_RENTALPRICEWEEK PRICE_FOR_WEEKS,
  nvl(m.MONTHS, 0), nvl(m.MONTHS, 0) * a.SAL_RENTALPRICEMONTH PRICE_FOR_MONTHS,
  nvl(d.DAYS, 0) * a.SAL_RENTALPRICEDAY + nvl(w.WEEKS, 0) * a.SAL_RENTALPRICEWEEK + nvl(m.MONTHS, 0) * a.SAL_RENTALPRICEMONTH TOTAL
FROM(
  SELECT a.ID_article, SUM(r.rentto - r.rentFROM) DAYS
  FROM article a left join rent r on a.ID_article = r.ID_article
  WHERE (r.rentTO - r.rentFROM) < 7
  AND extract(month FROM r.rentFROM) = extract(month FROM sysdate)
  and r.ID_customer = 11
  GROUP BY a.ID_article
) d full outer join (
  SELECT a.ID_article, SUM(trunc((r.rentto - r.rentFROM)/7)) WEEKS
  FROM article a left join rent r on a.ID_article = r.ID_article
  WHERE (r.rentTO - r.rentFROM) < 30
  AND extract(month FROM r.rentFROM) = extract(month FROM sysdate)
  and r.ID_customer = 11
  GROUP BY a.ID_article
) w on d.ID_article = w.ID_article
full outer join (
  SELECT a.ID_article, SUM(trunc((r.rentto - r.rentFROM)/30)) MONTHS
  FROM article a left join rent r on a.ID_article = r.ID_article
  WHERE (r.rentTO - r.rentFROM) >= 30
  AND extract(month FROM r.rentFROM) = extract(month FROM sysdate)
  and r.ID_customer = 11
  GROUP BY a.ID_article
) m on w.ID_article = m.ID_article
inner join article a on d.ID_article = a.ID_article or w.ID_article = a.ID_article or m.ID_article = a.ID_article
ID_ARTICLE TYPE                                                             NVL(D.DAYS,0) PRICE_FOR_DAYS NVL(W.WEEKS,0) PRICE_FOR_WEEKS NVL(M.MONTHS,0) PRICE_FOR_MONTHS      TOTAL
---------- ---------------------------------------------------------------- ------------- -------------- -------------- --------------- --------------- ---------------- ----------
        17 Excavator                                                                    6            510              0               0               0                0        510

> -- 10. Monatliche Einnahmen von Depot nach Artikel
> SELECT 
  a.ID_article, a.TYPE,
  nvl(d.DAYS, 0), nvl(d.DAYS, 0) * a.SAL_RENTALPRICEDAY PRICE_FOR_DAYS,
  nvl(w.WEEKS, 0), nvl(w.WEEKS, 0) * a.SAL_RENTALPRICEWEEK PRICE_FOR_WEEKS,
  nvl(m.MONTHS, 0), nvl(m.MONTHS, 0) * a.SAL_RENTALPRICEMONTH PRICE_FOR_MONTHS,
  nvl(d.DAYS, 0) * a.SAL_RENTALPRICEDAY + nvl(w.WEEKS, 0) * a.SAL_RENTALPRICEWEEK + nvl(m.MONTHS, 0) * a.SAL_RENTALPRICEMONTH TOTAL
FROM(
  SELECT a.ID_article, SUM(r.rentto - r.rentFROM) DAYS
  FROM article a left join rent r on a.ID_article = r.ID_article
  WHERE (r.rentTO - r.rentFROM) < 7
  AND extract(month FROM r.rentFROM) = extract(month FROM sysdate)
  and a.ID_depot = 1
  GROUP BY a.ID_article
) d full outer join (
  SELECT a.ID_article, SUM(trunc((r.rentto - r.rentFROM)/7)) WEEKS
  FROM article a left join rent r on a.ID_article = r.ID_article
  WHERE (r.rentTO - r.rentFROM) < 30
  AND extract(month FROM r.rentFROM) = extract(month FROM sysdate)
  and a.ID_depot = 1
  GROUP BY a.ID_article
) w on d.ID_article = w.ID_article
full outer join (
  SELECT a.ID_article, SUM(trunc((r.rentto - r.rentFROM)/30)) MONTHS
  FROM article a left join rent r on a.ID_article = r.ID_article
  WHERE (r.rentTO - r.rentFROM) >= 30
  AND extract(month FROM r.rentFROM) = extract(month FROM sysdate)
  and a.ID_depot = 1
  GROUP BY a.ID_article
) m on w.ID_article = m.ID_article
right join article a on d.ID_article = a.ID_article or w.ID_article = a.ID_article or m.ID_article = a.ID_article
where a.ID_depot = 1
ID_ARTICLE TYPE                                                             NVL(D.DAYS,0) PRICE_FOR_DAYS NVL(W.WEEKS,0) PRICE_FOR_WEEKS NVL(M.MONTHS,0) PRICE_FOR_MONTHS      TOTAL
---------- ---------------------------------------------------------------- ------------- -------------- -------------- --------------- --------------- ---------------- ----------
        18 Excavator                                                                    6         1142,4              0               0               0                0     1142,4
        17 Excavator                                                                   12           1020              0               0               0                0       1020

> --
> -- Systemdatum Ende
> --
> SELECT user,
         TO_CHAR(SYSDATE, 'dd-mm-yy hh24:mi:ss') 
  FROM   dual
  
USER                           TO_CHAR(SYSDATE,'DD-MM-YYHH24:MI:SS')
------------------------------ -------------------------------------
PROBIN2S                       06-05-15 14:48:41                    

> --
> spool off
